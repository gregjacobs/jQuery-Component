<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global define */
define( [
	'jquery',
	'lodash',
	'jqc/util/Css',
	'jqc/ComponentManager',
	'jqc/form/field/Text'
], function( jQuery, _, Css, ComponentManager, TextField ) {
	
<span id='jqc-form-field-TextArea'>	/**
</span>	 * @class jqc.form.field.TextArea
	 * @extends jqc.form.field.Text
	 * 
	 * TextArea field component.
	 */
	var TextAreaField = TextField.extend( {
		
<span id='jqc-form-field-TextArea-cfg-autoGrow'>		/**
</span>		 * @cfg {Boolean} autoGrow
		 * True to auto-grow the text field as the user types into it. Defaults to false.
		 * 
		 * Note that if autoGrow is true, the textarea will be given the &quot;resize: none&quot; style for Chrome and Safari, so that
		 * the resize handle is removed. The resize handle does not make sense for auto-grow textareas because the textarea size
		 * is recalculated and applied on every key press (so if they drag it bigger, and then keep typing, it
		 * will just be resized back to its calculated height.
		 */
		autoGrow : false,
		
<span id='jqc-form-field-TextArea-cfg-componentCls'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		componentCls : 'jqc-form-TextAreaField',
		
		
<span id='jqc-form-field-TextArea-property-S-inputEl'>		/**
</span>		 * @protected
		 * @property {jQuery} $inputEl
		 * 
		 * The &amp;lt;input&amp;gt; element; the textarea field.
		 */
		
<span id='jqc-form-field-TextArea-property-autoGrowMimicStyles'>		/**
</span>		 * @private
		 * @property {String[]} autoGrowMimicStyles
		 * 
		 * An array of the CSS properties that should be applied to the div that will mimic the textarea's text when {@link #autoGrow}
		 * is true.
		 */
		autoGrowMimicStyles : [ 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'fontSize', 'lineHeight', 'fontFamily', 'width', 'fontWeight' ],
		
<span id='jqc-form-field-TextArea-property-S-autoGrowTwinDiv'>		/**
</span>		 * @private
		 * @property {jQuery} $autoGrowTwinDiv
		 * 
		 * A div element that is created if the {@link #autoGrow} config is true, to be a &quot;twin&quot; of the textarea. The content of the textarea will be copied to
		 * this div so that it can be measured for its height, and then that height value can be applied to the textarea itself to &quot;autogrow&quot; it.
		 */
		
<span id='jqc-form-field-TextArea-property-autoGrowComputedStyles'>		/**
</span>		 * @private
		 * @property {Object} autoGrowComputedStyles
		 * 
		 * An object that holds the computed styles for the {@link #autoGrow} feature.
		 */
		
<span id='jqc-form-field-TextArea-property-autoGrowPasteHandler'>		/**
</span>		 * @private 
		 * @property {Function} autoGrowPasteHandler
		 * 
		 * A reference to the function created as the document paste handler, for when {@link #autoGrow} is true. This reference is maintained so that
		 * the document level handler can be removed when the field is destroyed.
		 */
		
		
		
<span id='jqc-form-field-TextArea-method-onRender'>		/**
</span>		 * @inheritdoc
		 */
		onRender : function() {
			this._super( arguments );
			
			
			// If there was a 'height' configured on the Component, size the actual textarea element according to the heights
			// of the other elements that are part of the field.
			if( 'height' in this ) {
				var inputElHeight = this.height;
				
				// Leave room for a &quot;top&quot; label
				if( this.labelAlign === 'top' ) {
					inputElHeight -= this.$labelEl.outerHeight( /* includeMargin */ true );
				}
				
				// Minus off the top/bottom margin/padding of the $inputContainerEl and the $inputEl itself
				inputElHeight -= Css.getMargin( this.$inputContainerEl, 'tb' ) + Css.getPadding( this.$inputContainerEl, 'tb' );
				inputElHeight -= Css.getMargin( this.$inputEl, 'tb' ) + Css.getPadding( this.$inputEl, 'tb' );
				
				// And finally, minus off the height of the &quot;extraMsg&quot; element (if there is actually 'extraMsg' text)
				if( this.extraMsg ) {
					inputElHeight -= this.$extraMsgEl.outerHeight( /* includeMargin */ true );
				}
				
				this.$inputEl.css( 'height', inputElHeight + 'px' );
			}
			
			
			// Handle autogrowing textareas
			if( this.autoGrow ) {
				var mimicStyles = this.autoGrowMimicStyles,
				    $textarea   = this.$inputEl,
				    $twin       = jQuery( '&lt;div /&gt;' ).css( { 'position': 'absolute', 'display': 'none', 'word-wrap': 'break-word' } ),
				    lineHeight  = parseInt( $textarea.css( 'line-height' ), 10 ) || parseInt( $textarea.css( 'font-size' ), 10 ),
				    minHeight   = parseInt( $textarea.css( 'height' ), 10 ) || lineHeight * 3,
				    maxHeight   = parseInt( $textarea.css( 'max-height' ), 10 ) || Number.MAX_VALUE;
				
				// Opera returns max-height of -1 if not set
				if( maxHeight &lt; 0 ) {
					maxHeight = Number.MAX_VALUE;
				}
				
				// For Chrome and Safari, remove the browser-inserted &quot;resize&quot; handle. It doesn't make sense for auto-grow textareas
				// because the size is recalculated and applied on every key press (so if they drag it bigger, and then keep typing, it
				// will just be resized back to its calculated height.
				$textarea.css( 'resize', 'none' );
				
				// Store the lineHeight, minHeight, and maxHeight values
				this.autoGrowComputedStyles = {
					lineHeight : lineHeight,
					minHeight  : minHeight,
					maxHeight  : maxHeight
				};
				
				
				// Append the twin to the DOM
				// We are going to measure the height of this, not the textarea.
				$twin.appendTo( $textarea.parent() );
				
				// Copy the essential styles (mimics) from the textarea to the twin
				var i = mimicStyles.length;
				while( i-- ) {
					$twin.css( mimicStyles[ i ], $textarea.css( mimicStyles[ i ] ) );
				}
				
				
				// Hide scrollbars, but make sure that the height of the $textarea doesn't shrink when setting to overflow: hidden
				$textarea.css( 'minHeight', minHeight );
				$textarea.css( 'overflow', 'hidden' );
				
				
				
				// Update textarea size on cut and paste
				$textarea.on( 'cut paste', _.bind( function() { this.updateAutoGrowHeight(); }, this ) );
				
				
				// Attempt to catch the browser paste event.
				var me = this;  // for closure
				this.autoGrowPasteHandler = function() {   
					setTimeout( function() { me.updateAutoGrowHeight(); }, 250 );  // need timeout because the paste event fires just *before* the paste is done
				};
				$textarea.on( 'paste input', this.autoGrowPasteHandler );
				
				// Save a reference to the twin element
				this.$autoGrowTwinDiv = $twin;
				
				// Run the sizing routine now that we're all set up
				this.updateAutoGrowHeight();
			}
		},
		
		
<span id='jqc-form-field-TextArea-method-createInputEl'>		/**
</span>		 * Overridden method for creating the input element for the TextAreaField. This implementation
		 * creates a &amp;lt;textarea&amp;gt; element. See {@link jqc.form.field.Text#createInputEl} for more information.
		 * 
		 * @protected
		 * @return {jQuery}
		 */
		createInputEl : function() {
			return jQuery( [ 
				'&lt;textarea',
				' id=&quot;' + this.inputId + '&quot;',
				' name=&quot;' + this.inputName + '&quot;',
				' class=&quot;' + this.componentCls + '-input&quot;',
				( this.readOnly ? ' readonly=&quot;readonly&quot;' : '' ),
				'&gt;',
					( this.value || &quot;&quot; ),
				'&lt;/textarea&gt;'
			].join( &quot;&quot; ) );  
		},
		
		
		// ----------------------------------------
		
		// AutoGrow Methods
		
		
<span id='jqc-form-field-TextArea-method-setHeightAndOverflow'>		/**
</span>		 * Utility method for the {@link #autoGrow} functionality. Sets a given `height` and `overflow` state on the textarea.
		 * 
		 * @private
		 * @param {Number} height
		 * @param {String} overflow
		 */ 
		setHeightAndOverflow : function( height, overflow ) {
			var $textarea = this.$inputEl,
			    curatedHeight = Math.floor( parseInt( height, 10 ) );
			    
			if( $textarea.height() !== curatedHeight ) {
				$textarea.css( { 'height': curatedHeight + 'px', 'overflow': overflow } );
			}
		},
		
		
		
<span id='jqc-form-field-TextArea-method-updateAutoGrowHeight'>		/**
</span>		 * Utility method for the {@link #autoGrow} functionality. Update the height of the textarea, if necessary.
		 * 
		 * @private
		 */
		updateAutoGrowHeight : function() {
			if( this.rendered ) {
				var $textarea = this.$inputEl,
				    $twin = this.$autoGrowTwinDiv,
				    computedStyles = this.autoGrowComputedStyles;
				
				// Get curated content from the textarea.
				var textareaContent = $textarea.val().replace( /&amp;/g,'&amp;amp;' ).replace( / {2}/g, '&amp;nbsp;' ).replace( /&lt;|&gt;/g, '&amp;gt;' ).replace( /\n/g, '&lt;br /&gt;' );
				
				// Compare curated content with curated twin.
				var twinContent = $twin.html().replace( /&lt;br&gt;/ig, '&lt;br /&gt;' );
				if( textareaContent + '&amp;nbsp;' !== twinContent ) {
					// Add an extra white space so new rows are added when you are at the end of a row.
					$twin.html( textareaContent + '&amp;nbsp;' );
					
					// Change textarea height if twin plus the height of one line differs more than 3 pixel from textarea height
					if( Math.abs( $twin.height() + computedStyles.lineHeight - $textarea.height() ) &gt; 3 ) {
						var goalHeight = $twin.height() + computedStyles.lineHeight;
						
						if( goalHeight &gt;= computedStyles.maxHeight ) {
							this.setHeightAndOverflow( computedStyles.maxHeight, 'auto' );
							
						} else if( goalHeight &lt;= computedStyles.minHeight ) {
							this.setHeightAndOverflow( computedStyles.minHeight, 'hidden' );
							
						} else {
							this.setHeightAndOverflow( goalHeight, 'hidden' );
						}
					}
				}
			}
		},
		
		
		// protected
		setValue : function() {
			this._super( arguments );
			
			// After the value is set, update the &quot;auto grow&quot; height
			if( this.autoGrow ) {
				this.updateAutoGrowHeight();
			}
		},
		
		
		// protected
		onChange : function() {
			this._super( arguments );
			
			if( this.autoGrow ) {
				this.updateAutoGrowHeight();
			}
		},
		
		
		// protected
		onKeyUp : function( evt ) {
			this._super( arguments );
			
			if( this.autoGrow ) {
				this.updateAutoGrowHeight();
			}
		},
		
		
		// protected
		onBlur : function() {
			this._super( arguments );
			
			// Compact textarea on blur (if the autoGrow config is true)
			if( this.autoGrow ) {
				var $textarea = this.$inputEl,
				    $twin = this.$autoGrowTwinDiv,
				    computedStyles = this.autoGrowComputedStyles;
				
				if( $twin.height() &lt; computedStyles.maxHeight ) {
					if( $twin.height() &gt; computedStyles.minHeight ) {
						$textarea.height( $twin.height() );
					} else {
						$textarea.height( computedStyles.minHeight );
					}
				}
			}
		},
		
		
		// ----------------------------------------
		
		
		// protected
		onDestroy : function() {
			if( this.autoGrow &amp;&amp; this.rendered ) {
				// Remove the sizing div
				this.$autoGrowTwinDiv.remove();
			}
			
			this._super( arguments );
		}
		
	} );
	
	
	// Register the class so it can be created by the type string 'textareafield'
	ComponentManager.registerType( 'textareafield', TextAreaField );
	
	return TextAreaField;
	
} );</pre>
</body>
</html>
