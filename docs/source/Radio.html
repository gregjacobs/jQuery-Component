<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global define */
define( [
	'jquery',
	'lodash',
	'jqc/ComponentManager',
	'jqc/form/field/Field',
	'jqc/template/LoDash',
	'jqc/util/OptionsStore'
], function( jQuery, _, ComponentManager, Field, LoDashTpl, OptionsStore ) {
	
<span id='jqc-form-field-Radio'>	/**
</span>	 * @class jqc.form.field.Radio
	 * @extends jqc.form.field.Field
	 * 
	 * Set of radio buttons (buttons where only one selection can be made at a time).
	 */
	var RadioField = Field.extend( {
		
<span id='jqc-form-field-Radio-cfg-stacked'>		/**
</span>		 * @cfg {Boolean} stacked 
		 * 
		 * `true` if the radio buttons should be stacked instead of spread out horizontally across the line.
		 */
		stacked : false,
		
<span id='jqc-form-field-Radio-cfg-options'>		/**
</span>		 * @cfg {Array/Function} options (required)
		 * 
		 * The options for the RadioField, which creates the radio button based on this config. This config is required.
		 * 
		 * If this is a flat array, the values will be used as both the value and text
		 * of the ButtonSet options.  Ex: `[ &quot;Yes&quot;, &quot;No&quot; ]`
		 * 
		 * If you want to customize the value and text separately for each option (recommended), provide an array of objects, where the object has two
		 * properties: `text` and `value`. Ex: `[ { &quot;text&quot;: &quot;Yes&quot;, &quot;value&quot;: &quot;yes&quot; }, { &quot;text&quot;: &quot;No&quot;, &quot;value&quot;: &quot;no&quot; } ]`
		 * 
		 * If this config is specified as a function, the function will be executed, and its return will be used as the options. Its return should match one of
		 * the array forms defined above.
		 */
		
<span id='jqc-form-field-Radio-cfg-inputName'>		/**
</span>		 * @cfg {String} inputName
		 * 
		 * The name to give the input. This will be set as the input's &quot;name&quot; attribute.  This is really only useful if
		 * the form that the component exists in is going to be submitted by a standard form submission (as opposed to just
		 * having its values retrieved, which are handled elsewhere). Defaults to the value of the 
		 * {@link jqc.form.field.Field#inputId} config.
		 * 
		 * Note that because radio fields rely on their &quot;name&quot; attributes being the same, this should not be set to an
		 * empty string (or another non-unique string).  If an explicit name is not needed, let this config default to the
		 * {@link jqc.form.field.Field#inputId} config.
		 */
		
<span id='jqc-form-field-Radio-cfg-componentCls'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		componentCls : 'jqc-form-RadioField',
		
		
<span id='jqc-form-field-Radio-property-radioTpl'>		/**
</span>		 * @protected
		 * @property {String} radioTpl
		 * 
		 * The HTML template to use to create the radio elements.
		 */
		radioTpl : new LoDashTpl( [
			'&lt;input type=&quot;radio&quot; id=&quot;&lt;%= name %&gt;-&lt;%= num %&gt;&quot; name=&quot;&lt;%= name %&gt;&quot; class=&quot;&lt;%= componentCls %&gt;-input&quot; value=&quot;&lt;%= inputValue %&gt;&quot; &lt;% if( checked ) { %&gt;checked&lt;% } %&gt;&gt;',
			'&lt;label for=&quot;&lt;%= name %&gt;-&lt;%= num %&gt;&quot; class=&quot;&lt;%= componentCls %&gt;-label&quot;&gt;&lt;%= text %&gt;&lt;/label&gt;'
		] ),
		
		
		
<span id='jqc-form-field-Radio-method-initComponent'>		/**
</span>		 * @inheritdoc
		 */
		initComponent : function() {
			// Create the OptionsStore for managing the 'options'
			this.optionsStore = new OptionsStore( this.options );
			
			// Make sure that options were provided
			// &lt;debug&gt;
			if( this.optionsStore.getOptions().length === 0 ) {
				throw new Error( &quot;Error: The ButtonSet's 'options' was not configured.&quot; );
			}
			// &lt;/debug&gt;
			
			if( typeof this.value === 'undefined' ) {
				// No 'value' config provided, set the value to the value of the first option
				this.value = this.optionsStore.getOptions()[ 0 ].value;
				
			} else {
				// Value config was provided, make sure it is in the options store. If not, 
				// set it to the value of the first option. This guarantees that the RadioField's
				// value is always set to a valid option
				if( this.optionsStore.getByValue( this.value ) === null ) {
					this.value = this.optionsStore.getOptions()[ 0 ].value;
				}
			}
			
			
			// Call superclass initComponent
			this._super( arguments );
			
			
			// Make sure there is an inputName. This is needed for the radio functionality. It should have been created by Field if it wasn't provided,
			// but this will make sure just in case.
			// &lt;debug&gt;
			if( !this.inputName ) {
				throw new Error( &quot;Error: RadioField must have a valid inputName. Make sure that the inputName and inputId configs have not been set to an empty string or other falsy value.&quot; );
			}
			// &lt;/debug&gt;
		},
		
		
<span id='jqc-form-field-Radio-method-onRender'>		/**
</span>		 * @inheritdoc
		 */
		onRender : function( container ) {
			// Call superclass onRender() first, to render this Component's element
			this._super( arguments );
			
			var options = this.optionsStore.getOptions(),
			    radioTpl = this.radioTpl,
				inputName = this.inputName,
				$inputContainerEl = this.$inputContainerEl,
				stacked = this.stacked,
				fieldValue = this.value,
				markup = [];
			
			for( var i = 0, len = options.length; i &lt; len; i++ ) {
				var option = options[ i ];
				
				// Append the radio
				markup.push( 
					radioTpl.apply( {
						componentCls : this.componentCls,
						
						name         : inputName,
						num          : i,
						inputValue   : option.value,
						text         : option.text,
						checked      : ( fieldValue === option.value )
					} )
				);
				if( stacked ) {
					markup.push( '&lt;br /&gt;' );     // If the radio's are to be stacked, append a line break
				}
			}
			
			// Append the markup
			$inputContainerEl.append( markup.join( &quot;&quot; ) );
			
			// Assign event handler to the container element, taking advantage of event bubbling
			$inputContainerEl.on( {
				'change' : _.bind( function() { this.onChange( this.getValue() ); }, this )  // Call onChange() with the new value
			} );
		},
		
		
		
<span id='jqc-form-field-Radio-method-setValue'>		/**
</span>		 * Implementation of {@link jqc.form.field.Field Field}'s setValue() method, which sets the value to the field.
		 * 
		 * @param {String} value The value of the field.
		 */
		setValue : function( value ) {
			// If there is an option with the provided value, set it. Otherwise, don't set anything.
			var option = this.optionsStore.getByValue( value );
			
			if( option !== null ) {
				if( !this.rendered ) {
					this.value = value;  // If the Component has not yet been rendered (i.e. the Field has not yet been created), store the value as the initial value to set.	
					
				} else {
					this.$inputContainerEl.find( ':radio[value=' + value + ']' ).prop( 'checked', true );
				}
			}
		},
		
		
<span id='jqc-form-field-Radio-method-getValue'>		/**
</span>		 * Implementation of {@link jqc.form.field.Field Field}'s getValue() method, which returns the value of the field.
		 * 
		 * @return {String} The value of the field.
		 */
		getValue : function() {
			if( !this.rendered ) {
				return this.value;  // If the value was set before the Component has been rendered (i.e. before the Field has been created), return that.
			} else {
				return this.$inputContainerEl.find( ':radio:checked' ).val();
			}
		}
		
	} );
	
	
	// Register the class so it can be created by the type string 'radiofield'
	ComponentManager.registerType( 'radiofield', RadioField );
	
	return RadioField;
	
} );</pre>
</body>
</html>
