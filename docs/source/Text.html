<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global define */
define( [
	'jquery',
	'lodash',
	'jqc/util/Html',
	'jqc/ComponentManager',
	'jqc/form/field/Field',
	'jqc/form/field/Text.EmptyTextBehavior',
	'jqc/form/field/Text.InfieldLabelBehavior'
], function( jQuery, _, Html, ComponentManager, Field, EmptyTextBehavior, InfieldLabelBehavior ) {
	
<span id='jqc-form-field-Text'>	/**
</span>	 * @class jqc.form.field.Text
	 * @extends jqc.form.field.Field
	 * 
	 * Text (string) field component for the editor.
	 */
	var TextField = Field.extend( {
		
<span id='jqc-form-field-Text-cfg-selectOnFocus'>		/**
</span>		 * @cfg {Boolean} selectOnFocus
		 * True to have the field's text automatically selected when the field is focused. Defaults to false. 
		 */
		selectOnFocus : false,
		
<span id='jqc-form-field-Text-cfg-labelAlign'>		/**
</span>		 * @cfg {String} labelAlign
		 * A string that specifies where the field's label should be placed. Valid values are: &quot;left&quot;, &quot;top&quot;, 
		 * and &quot;infield&quot;. The &quot;infield&quot; label position places the label inside the text field itself, which 
		 * is then hidden when the user starts typing into the field. Defaults to 'left'.
		 * 
		 * Note that a labelAlign set to &quot;infield&quot; is not compatible with the {@link #emptyText} 
		 * config. The provided {@link #emptyText} will not be used in this case. 
		 */
		
<span id='jqc-form-field-Text-cfg-emptyText'>		/**
</span>		 * @cfg {String} emptyText
		 * The text to show in the field when the field is empty. When the user focuses the field, this text
		 * will be removed, allowing the user to type their value. If provided, and no {@link #value} is provided,
		 * the {@link #value} will be set to this.
		 * 
		 * Note that this is not compatible with the {@link #labelAlign} config set to &quot;infield&quot;. See the description of {@link #labelAlign}.
		 */
		
<span id='jqc-form-field-Text-cfg-restoreEmptyText'>		/**
</span>		 * @cfg {Boolean} restoreEmptyText
		 * True to enable the restoration of the {@link #emptyText} (if any) when the field loses focus (is blurred), and is empty.
		 * If this is true, the {@link #emptyText} will be re-applied to the field when it has no value (i.e. it's an
		 * empty string).  If this is false, the {@link #emptyText} will not be re-applied to the field when it loses 
		 * focus. Defaults to true.
		 * 
		 * Note: This only applies when the {@link #labelAlign} config is not &quot;infield&quot;. Infield labels cannot have
		 * an {@link #emptyText} value.
		 */
		restoreEmptyText : true,
		
<span id='jqc-form-field-Text-cfg-value'>		/**
</span>		 * @cfg {String} value
		 * The initial value for the field, if any.
		 */
		
<span id='jqc-form-field-Text-cfg-readOnly'>		/**
</span>		 * @cfg {Boolean} readOnly
		 * 
		 * True to mark the Field as &quot;read only&quot; in the HTML. This prevents the user from editing the Field.
		 */
		
<span id='jqc-form-field-Text-cfg-componentCls'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		componentCls : 'jqc-form-TextField',
		
		
<span id='jqc-form-field-Text-property-S-inputEl'>		/**
</span>		 * @protected
		 * @property {jQuery} $inputEl
		 * 
		 * The &amp;lt;input&amp;gt; element; the text field. Will only be available after render.
		 */
		
<span id='jqc-form-field-Text-property-behaviorState'>		/**
</span>		 * @private
		 * @property {jqc.form.field.Text.Behavior} behaviorState
		 * 
		 * The {@link jqc.form.field.Text.Behavior} object that governs the TextField's behavior.
		 * This currently applies to either the TextField having an {@link #emptyText} value, 
		 * or the TextField having an &quot;infield&quot; {@link #labelAlign}.
		 */
		
		
<span id='jqc-form-field-Text-method-initComponent'>		/**
</span>		 * @inheritdoc
		 */
		initComponent : function() {
			this._super( arguments );
			
			this.addEvents(
<span id='jqc-form-field-Text-event-keydown'>				/**
</span>				 * Fires when a key is pressed down in the field.
				 * 
				 * @event keydown
				 * @param {jqc.form.field.Field} field This TextField object.
				 * @param {jQuery.Event} evt The jQuery event object for the event.
				 */
				'keydown',
				
<span id='jqc-form-field-Text-event-keyup'>				/**
</span>				 * Fires when a key is pressed and let up in the field.
				 * 
				 * @event keyup
				 * @param {jqc.form.field.Field} field This TextField object.
				 * @param {jQuery.Event} evt The jQuery event object for the event.
				 */
				'keyup',
				
<span id='jqc-form-field-Text-event-keypress'>				/**
</span>				 * Fires when a key is pressed in the field.
				 * 
				 * @event keypress
				 * @param {jqc.form.field.Field} field This TextField object.
				 * @param {jQuery.Event} evt The jQuery event object for the event.
				 */
				'keypress'
			);
			
			// Set the TextField's behavior &quot;state&quot;, based on if it is set to have an &quot;infield&quot; label or not.
			// &quot;infield&quot; labels are incompatible with having a regular default value (i.e. the default showing on top
			// of the &quot;infield&quot; label does not look right), and thus are mutually exclusive behaviors.
			if( this.labelAlign === 'infield' ) {
				this.behaviorState = new InfieldLabelBehavior();
			} else {
				this.behaviorState = new EmptyTextBehavior();
			}
			
			// If a value was provided, and it is not a string, convert it to one now. normalizeValue handles all datatypes.
			this.value = this.normalizeValue( this.value );
			
			// If the value is an empty string, and there was emptyText provided, initialize it to the emptyText.
			// That is what will be displayed in the field (with the appropriate CSS class to make it look like the emptyText).
			if( this.value === &quot;&quot; &amp;&amp; this.emptyText ) {
				this.value = this.emptyText;
			}
		},
		
		
<span id='jqc-form-field-Text-method-onRender'>		/**
</span>		 * @inheritdoc
		 */
		onRender : function( container ) {
			// Call superclass onRender()
			this._super( arguments );
			
			// Create the input field, and append it to the $inputContainerEl with the 'text' css class
			var $inputEl = this.$inputEl = this.createInputEl().appendTo( this.$inputContainerEl );
			
			// Add event handlers to the input element
			$inputEl.on( {
				change   : _.bind( function( evt ) { this.onChange( this.getValue() ); }, this ),  // Call onChange() with the new value
				focus    : _.bind( this.onFocus, this ),
				blur     : _.bind( this.onBlur, this ),
				keydown  : _.bind( this.onKeyDown, this ),
				keyup    : _.bind( this.onKeyUp, this ),
				keypress : _.bind( this.onKeyPress, this )
			} );
			
			// Call state object's onRender to allow it to implement whatever processing is necessary
			this.behaviorState.onRender( this );
		},
		
		
<span id='jqc-form-field-Text-method-createInputEl'>		/**
</span>		 * Overridable method for creating the input element for the TextField. This may be overrided in a subclass for
		 * a different implementation than the regular &amp;lt;input type=&quot;text&quot;&amp;gt; element.  The implementation should
		 * add the field's &quot;id&quot; ({@link #inputId}) and &quot;name&quot; ({@link #inputName}) properties, and populate the field's
		 * initial {@link #value}.
		 * 
		 * @protected
		 * @return {jQuery}
		 */
		createInputEl : function() {
			var value = Html.encode( this.value || &quot;&quot; );
			return jQuery( [ 
				'&lt;input type=&quot;text&quot;',
				' id=&quot;' + this.inputId + '&quot;',
				' name=&quot;' + this.inputName + '&quot;',
				' class=&quot;' + this.componentCls + '-input&quot;',
				' value=&quot;' + value + '&quot;',
				( this.readOnly ? ' readonly=&quot;readonly&quot;' : '' ),
				'/&gt;'
			].join( &quot;&quot; ) );
		},
		
		
<span id='jqc-form-field-Text-method-getInputEl'>		/**
</span>		 * Retrieves the input element from the TextField. Use only if absolutely needed however, otherwise relying on the public
		 * interface to this class to perform common tasks such as getting/setting the value, or focusing/blurring the field.  
		 * This is mainly an accessor for the bevhavior state objects that operate on this class. The input element will not be
		 * available until the TextField has been rendered.
		 * 
		 * @return {jQuery} The input element if the component is rendered, or null if it is not.
		 */
		getInputEl : function() {
			return this.$inputEl || null;
		},
		
		
<span id='jqc-form-field-Text-method-normalizeValue'>		/**
</span>		 * Normalizes the value provided to a valid TextField value. Converts undefined/null into an empty string,
		 * and numbers/booleans/objects into their string form.
		 * 
		 * @protected
		 * @param {Mixed} value
		 * @return {String}
		 */
		normalizeValue : function( value ) {
			// Normalize undefined/null to an empty string, and numbers/booleans/objects to their string representation.
			// Otherwise, return string values unchanged.
			if( typeof value === 'undefined' || value === null ) {
				return &quot;&quot;;
			} else if( typeof value !== 'string' ) {
				return value.toString();
			} else {
				return value;
			}
		},
		
		
<span id='jqc-form-field-Text-method-setValue'>		/**
</span>		 * Implementation of {@link jqc.form.field.Field Field}'s setValue() method, which sets the value to the field.
		 * 
		 * @param {String} value The value of the field.
		 */
		setValue : function( value ) {
			value = this.normalizeValue( value );
			
			if( !this.rendered ) {
				this.value = value;  // If the Component has not yet been rendered (i.e. the Field has not yet been created), store the value as the initial value to set.
				
			} else {
				this.$inputEl.val( value );
				
				// Allow the TextField's behaviorState to handle the value being set
				this.behaviorState.onSetValue( this, value );
			}
			
			// Run onchange, to notify listeners of a change
			this.onChange( value );
		},
		
		
<span id='jqc-form-field-Text-method-getValue'>		/**
</span>		 * Implementation of {@link jqc.form.field.Field Field}'s getValue() method, which returns the value of the field.
		 * 
		 * @return {String} The value of the field.
		 */
		getValue : function() {
			if( !this.rendered ) {
				// If the value was set before the Component has been rendered (i.e. before the Field has been created), return that.
				return this.value;
				
			} else {
				return this.$inputEl.val();
			}
		},
		
		
<span id='jqc-form-field-Text-method-setEmptyText'>		/**
</span>		 * Sets the {@link #emptyText} for the Field.
		 * 
		 * @param {Mixed} emptyText The empty text to set to the Field.
		 */
		setEmptyText : function( emptyText ) {
			this.emptyText = emptyText;
		},
		
		
<span id='jqc-form-field-Text-method-getEmptyText'>		/**
</span>		 * Retrieves the {@link #emptyText} of the Field.
		 * 
		 * @return {Mixed} The {@link #emptyText} that was specified for the Field, or set using {@link #setEmptyText}.
		 */
		getEmptyText : function() {
			return this.emptyText;
		},
		
		
<span id='jqc-form-field-Text-method-select'>		/**
</span>		 * Selects the text in the TextField.
		 */
		select : function() {
			this.$inputEl.select();
		},
		
		
<span id='jqc-form-field-Text-method-onChange'>		/**
</span>		 * Extension of onChange template method used to allow the {@link #behaviorState} to handle
		 * the change event.
		 *
		 * @protected
		 */
		onChange : function() {
			// Allow the TextField's behaviorState to handle the change event
			this.behaviorState.onChange( this );
			
			this._super( arguments );
		},
		
		
<span id='jqc-form-field-Text-method-focus'>		/**
</span>		 * Focuses the text field.
		 * 
		 * @chainable
		 */
		focus : function() {
			this.$inputEl.focus();
			
			return this._super( arguments );
		},
		
		
<span id='jqc-form-field-Text-method-blur'>		/**
</span>		 * Blurs the text field.
		 * 
		 * @chainable
		 */
		blur : function() {
			this.$inputEl.blur();
			
			return this._super( arguments );
		},
		
		
<span id='jqc-form-field-Text-method-onFocus'>		/**
</span>		 * @inheritdoc
		 */
		onFocus : function() {
			// Allow the TextField's behaviorState to handle the focus event
			this.behaviorState.onFocus( this );
			
			// If the selectOnFocus config is true, select the text
			if( this.selectOnFocus ) {
				this.select();
			}
			
			this._super( arguments );
		},
		
		
<span id='jqc-form-field-Text-method-onBlur'>		/**
</span>		 * @inheritdoc
		 */
		onBlur : function() {
			// Allow the TextField's behaviorState to handle the blur event
			this.behaviorState.onBlur( this );
			
			this._super( arguments );
		},
		
		
<span id='jqc-form-field-Text-method-onKeyDown'>		/**
</span>		 * Handles a keydown event in the text field. 
		 * 
		 * @protected
		 * @param {jQuery.Event} evt The jQuery event object for the event.
		 */
		onKeyDown : function( evt ) {
			// Allow the TextField's behaviorState to handle the keydown event
			this.behaviorState.onKeyDown( this, evt );
			
			this.fireEvent( 'keydown', this, evt ); 
		},
		
		
<span id='jqc-form-field-Text-method-onKeyUp'>		/**
</span>		 * Handles a keyup event in the text field. 
		 * 
		 * @protected
		 * @param {jQuery.Event} evt The jQuery event object for the event.
		 */
		onKeyUp : function( evt ) {
			// Allow the TextField's behaviorState to handle the keyup event
			this.behaviorState.onKeyUp( this, evt );
			
			this.fireEvent( 'keyup', this, evt );
		},
		
		
<span id='jqc-form-field-Text-method-onKeyPress'>		/**
</span>		 * Handles a keypress in the text field. 
		 * 
		 * @protected
		 * @param {jQuery.Event} evt The jQuery event object for the event.
		 */
		onKeyPress : function( evt ) {
			// Allow the TextField's behaviorState to handle the keypress event
			this.behaviorState.onKeyPress( this, evt );
			
			this.fireEvent( 'keypress', this, evt ); 
		}
		
	} );
	
	
	// Register the class so it can be created by the type string 'textfield'
	ComponentManager.registerType( 'textfield', TextField );

	return TextField;
	
} );</pre>
</body>
</html>
