/*!
 * Kevlar JS Library
 * Copyright(c) 2011 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.anim"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.containers"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.formFields"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.layouts"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.utils"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.anim"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.containers"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.formFields"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.layouts"});Ext.test.Session.addSuite("Kevlar.ui",{name:"Kevlar.ui.utils"});Ext.test.Session.addTest({name:"Kevlar.CSS","hashToString() should return an empty string when providing an empty hash":function(){Y.Assert.areSame("",Kevlar.CSS.hashToString({}))},"hashToString() should convert a hash of property/value pairs to a CSS string":function(){var a={color:"red","font-size":"12px"};Y.Assert.areSame("color:red;font-size:12px;",Kevlar.CSS.hashToString(a))},"hashToString() should convert camelCase style properties to their 'dash' form for the resulting string":function(){var a={fontFamily:"Arial",fontSize:"12px"};Y.Assert.areSame("font-family:Arial;font-size:12px;",Kevlar.CSS.hashToString(a))}});Ext.test.Session.addSuite({name:"Kevlar",items:[{name:"Test apply()",test_apply:function(){var f=Kevlar.apply({},{foo:1,bar:2});Y.ObjectAssert.hasKeys(f,{foo:1,bar:2},"Test simple apply, with a return value");var e={};Kevlar.apply(e,{opt1:"x",opt2:"y"});Y.ObjectAssert.hasKeys(e,{opt1:"x",opt2:"y"},"Test that the reference is changed");var d=Kevlar.apply({},{prop1:1});Y.Assert.isUndefined(d.prop2,"Test to ensure no extra properties are copied");var c=Kevlar.apply({foo:1,baz:4},{foo:2,bar:3});Y.ObjectAssert.hasKeys(c,{foo:2,bar:3,baz:4},"Ensure that properties get overwritten by defaults");var b={};Kevlar.apply(b,{foo:"new",exist:true},{foo:"old",def:true});Y.ObjectAssert.hasKeys(b,{foo:"new",def:true,exist:true},"Test using defaults");var a=Kevlar.apply({},{foo:"foo",bar:"bar"},{foo:"oldFoo",bar:"oldBar"});Y.ObjectAssert.hasKeys(a,{foo:"foo",bar:"bar"},"Test to ensure all defaults get overridden");Y.Assert.isNull(Kevlar.apply(null,{}),"Test null first argument")}},{name:"Test applyIf()",test_applyIf:function(){var d=Kevlar.applyIf({},{foo:"foo",bar:"bar"});Y.ObjectAssert.hasKeys(d,{foo:"foo",bar:"bar"},"Test with an empty destination object");var c=Kevlar.applyIf({foo:"foo"},{foo:"oldFoo"});Y.ObjectAssert.hasKeys(c,{foo:"foo"},"Ensure existing properties don't get overridden");var b=Kevlar.applyIf({foo:1,bar:2},{bar:3,baz:4});Y.ObjectAssert.hasKeys(b,{foo:1,bar:2,baz:4},"Test mixing properties to be overridden");var a={};Kevlar.applyIf(a,{foo:2},{foo:1});Y.ObjectAssert.hasKeys(a,{foo:2},"Test that the reference of the object is changed");Y.Assert.isNull(Kevlar.applyIf(null,{}),"Test null first argument")}},{name:"Test copyTo()",test_copyTo:function(){var e={x:50,y:100,width:"auto",height:200};var d=Kevlar.copyTo({},e,"x,y");Y.ObjectAssert.hasKeys(d,{x:50,y:100},"Test simple copy with string");var c=Kevlar.copyTo({},e,"");Y.Assert.isUndefined(c.x,"Test with empty string as properties");Y.Assert.isUndefined(c.y,"Test with empty string as properties");Y.Assert.isUndefined(c.width,"Test with empty string as properties");Y.Assert.isUndefined(c.height,"Test with empty string as properties");var b={};Kevlar.copyTo(b,e,"width");Y.ObjectAssert.hasKeys(b,{width:"auto"},"Test copy ensuring that the original reference is changed");var a=Kevlar.copyTo({x:1},e,["x","y"]);Y.ObjectAssert.hasKeys(a,{x:50,y:100},"Test with array as properties, also with an existing value in the destination object")}},{name:"Test each()",test_each:function(){var d=0;Kevlar.each([1,2,3,4],function(f){d+=f});Y.Assert.areEqual(10,d,"Simple each on an array of numbers");var c="";Kevlar.each(["T","e","s","t","i","n","g"],function(f){c+=f});Y.Assert.areEqual("Testing",c,"Simple each on array of strings");d=0;Kevlar.each(5,function(f){d+=f});Y.Assert.areEqual(5,d,"Test with a non array parameter, number");var e=false;Kevlar.each([],function(){e=true});Y.Assert.isFalse(e,"Test with empty array parameter");e=false;Kevlar.each(null,function(){e=true});Y.Assert.isFalse(e,"Test with null parameter");e=false;Kevlar.each(document.getElementsByTagName("body"),function(){e=true});Y.Assert.isTrue(e,"Test iteration over NodeLists");var a=[];Kevlar.each([1,2,3,4,5,6],function(g,f){a.push(f)});Y.ArrayAssert.itemsAreEqual([0,1,2,3,4,5],a,"Test index is passed correctly");d=0;Kevlar.each([1,2,3,4,5,6],function(f){if(f>4){return false}d+=f});Y.Assert.areEqual(10,d,"Test that returning false stops iteration");d=0;var b={value:3};Kevlar.each([1,2,3],function(f){d+=f*this.value},b);Y.Assert.areEqual(18,d,"Test scope argument #1");d=0;b={value:5};Kevlar.each([1,2,3],function(f){d+=f*this.value},b);Y.Assert.areEqual(30,d,"Test scope argument #2")}},{name:"Test escapeRe()",test_escapeRe:function(){Y.Assert.areEqual("\\-",Kevlar.escapeRe("-"),"Test with single char");Y.Assert.areEqual("\\*\\.",Kevlar.escapeRe("*."),"Test with multiple characters next to each other");Y.Assert.areEqual("foo",Kevlar.escapeRe("foo"),"Test with no escapeable chars");Y.Assert.areEqual("\\{baz\\}",Kevlar.escapeRe("{baz}"),"Test with mixed set");Y.Assert.areEqual("\\-\\.\\*\\+\\?\\^\\$\\{\\}\\(\\)\\|\\[\\]\\/\\\\",Kevlar.escapeRe("-.*+?^${}()|[]/\\"),"Test with every character")}},{name:"Test isArray()",test_isArray:function(){var a=Kevlar.extend(Object,{length:1});Y.Assert.isTrue(Kevlar.isArray([]),"Test with empty array");Y.Assert.isTrue(Kevlar.isArray([1,2,3,4]),"Test with filled array");Y.Assert.isFalse(Kevlar.isArray(false),"Test with boolean #1");Y.Assert.isFalse(Kevlar.isArray(true),"Test with boolean #2");Y.Assert.isFalse(Kevlar.isArray("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isArray(1),"Test with number");Y.Assert.isFalse(Kevlar.isArray(null),"Test with null");Y.Assert.isFalse(Kevlar.isArray(new Date()),"Test with a date");Y.Assert.isFalse(Kevlar.isArray({}),"Test with empty object");Y.Assert.isFalse(Kevlar.isArray(document.getElementsByTagName("body")),"Test with node list");Y.Assert.isFalse(Kevlar.isArray(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isArray(new a()),"Test with custom class that has a length property")}},{name:"Test isBoolean()",test_isBoolean:function(){Y.Assert.isTrue(Kevlar.isBoolean(true),"Test with true");Y.Assert.isTrue(Kevlar.isBoolean(false),"Test with false");Y.Assert.isFalse(Kevlar.isBoolean([]),"Test with empty array");Y.Assert.isFalse(Kevlar.isBoolean([1,2,3]),"Test with filled array");Y.Assert.isFalse(Kevlar.isBoolean(1),"Test with number");Y.Assert.isFalse(Kevlar.isBoolean(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isBoolean("foo"),"Test with non empty string");Y.Assert.isFalse(Kevlar.isBoolean(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isBoolean(null),"Test with null");Y.Assert.isFalse(Kevlar.isBoolean({}),"Test with object");Y.Assert.isFalse(Kevlar.isBoolean(new Date()),"Test with date")}},{name:"Test isDate()",test_isDate:function(){Y.Assert.isTrue(Kevlar.isDate(new Date()),"Test with simple date");Y.Assert.isTrue(Kevlar.isDate(Date.parseDate("2000","Y")),"Test with simple date");Y.Assert.isFalse(Kevlar.isDate(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isDate(1),"Test with number");Y.Assert.isFalse(Kevlar.isDate("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isDate(null),"Test with null");Y.Assert.isFalse(Kevlar.isDate([]),"Test with array");Y.Assert.isFalse(Kevlar.isDate({}),"Test with object");Y.Assert.isFalse(Kevlar.isDate(jQuery("body")[0]),"Test with element")}},{name:"Test isDefined()",test_isDefined:function(){Y.Assert.isFalse(Kevlar.isDefined(undefined),"Test with undefined");Y.Assert.isTrue(Kevlar.isDefined(null),"Test with null");Y.Assert.isTrue(Kevlar.isDefined({}),"Test with object");Y.Assert.isTrue(Kevlar.isDefined([]),"Test with array");Y.Assert.isTrue(Kevlar.isDefined(new Date()),"Test with date");Y.Assert.isTrue(Kevlar.isDefined(1),"Test with number");Y.Assert.isTrue(Kevlar.isDefined(false),"Test with boolean");Y.Assert.isTrue(Kevlar.isDefined(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isDefined("foo"),"Test with non-empty string");Y.Assert.isTrue(Kevlar.isDefined(jQuery("body")[0]),"Test with element")}},{name:"Test isElement()",test_isElement:function(){Y.Assert.isTrue(Kevlar.isElement(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isElement(null),"Test with null");Y.Assert.isFalse(Kevlar.isElement(1),"Test with number");Y.Assert.isFalse(Kevlar.isElement("foo"),"Test with string")}},{name:"Test isJQuery()",test_isJQuery:function(){Y.Assert.isFalse(Kevlar.isJQuery(jQuery("body")[0]),"Test with element");Y.Assert.isFalse(Kevlar.isJQuery(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isJQuery(null),"Test with null");Y.Assert.isFalse(Kevlar.isJQuery(1),"Test with number");Y.Assert.isFalse(Kevlar.isJQuery("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isJQuery(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isJQuery({}),"Test with anonymous object");Y.Assert.isFalse(Kevlar.isJQuery(Kevlar.emptyFn),"Test with function");Y.Assert.isFalse(Kevlar.isJQuery([]),"Test with array");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("body")),"Test with jQuery wrapped set object, with an element");Y.Assert.isTrue(Kevlar.isJQuery(jQuery("#non-existent-element")),"Test with jQuery wrapped set object, without any elements")}},{name:"Test isFunction()",test_isFunction:function(){var b=new Kevlar.util.Observable(),a={fn:function(){}};Y.Assert.isTrue(Kevlar.isFunction(function(){}),"Test with anonymous function");Y.Assert.isTrue(Kevlar.isFunction(new Function('return "";')),"Test with new Function syntax");Y.Assert.isTrue(Kevlar.isFunction(Kevlar.emptyFn),"Test with static function");Y.Assert.isTrue(Kevlar.isFunction(b.fireEvent),"Test with instance function");Y.Assert.isTrue(Kevlar.isFunction(a.fn),"Test with function on object");Y.Assert.isFalse(Kevlar.isFunction(Kevlar.version),"Test with class property");Y.Assert.isFalse(Kevlar.isFunction(null),"Test with null");Y.Assert.isFalse(Kevlar.isFunction(1),"Test with number");Y.Assert.isFalse(Kevlar.isFunction(""),"Test with string");Y.Assert.isFalse(Kevlar.isFunction(new Date()),"Test with date");Y.Assert.isFalse(Kevlar.isFunction([]),"Test with array");Y.Assert.isFalse(Kevlar.isFunction({}),"Test with object")}},{name:"Test isNumber()",test_isNumber:function(){Y.Assert.isTrue(Kevlar.isNumber(0),"Test with 0");Y.Assert.isTrue(Kevlar.isNumber(4),"Test with non-zero integer");Y.Assert.isTrue(Kevlar.isNumber(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isNumber(7.9),"Test with positive float");Y.Assert.isTrue(Kevlar.isNumber(-4.3),"Test with negative float");Y.Assert.isTrue(Kevlar.isNumber(Number.MAX_VALUE),"Test with MAX_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Number.MIN_VALUE),"Test with MIN_VALUE");Y.Assert.isTrue(Kevlar.isNumber(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isNumber(Number("3.1")),"Test with Number() constructor");Y.Assert.isFalse(Kevlar.isNumber(Number.NaN),"Test with NaN");Y.Assert.isFalse(Kevlar.isNumber(Number.POSITIVE_INFINITY),"Test with POSITIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(Number.NEGATIVE_INFINITY),"Test with NEGATIVE_INFINITY");Y.Assert.isFalse(Kevlar.isNumber(true),"Test with true");Y.Assert.isFalse(Kevlar.isNumber(""),"Test with empty string");Y.Assert.isFalse(Kevlar.isNumber("1.0"),"Test with string containing a number");Y.Assert.isFalse(Kevlar.isNumber(null),"Test with null");Y.Assert.isFalse(Kevlar.isNumber(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isNumber([]),"Test with array");Y.Assert.isFalse(Kevlar.isNumber({}),"Test with object")}},{name:"Test isObject()",test_isObject:function(){Y.Assert.isTrue(Kevlar.isObject({}),"Test with empty object");Y.Assert.isTrue(Kevlar.isObject({foo:1}),"Test with object with properties");Y.Assert.isTrue(Kevlar.isObject(new Kevlar.util.Observable()),"Test with object instance");Y.Assert.isTrue(Kevlar.isObject(new Object()),"Test with new Object(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(new Date()),"Test with a date object");Y.Assert.isFalse(Kevlar.isObject([]),"Test with array");Y.Assert.isFalse(Kevlar.isObject(new Array()),"Test with new Array(  ) syntax");Y.Assert.isFalse(Kevlar.isObject(1),"Test with number");Y.Assert.isFalse(Kevlar.isObject("foo"),"Test with string");Y.Assert.isFalse(Kevlar.isObject(false),"Test with boolean");Y.Assert.isFalse(Kevlar.isObject(new Number(3)),"Test with new Number() syntax");Y.Assert.isFalse(Kevlar.isObject(new String("foo")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isObject(null),"Test with null");Y.Assert.isFalse(Kevlar.isObject(undefined),"Test with undefined")}},{name:"Test isPrimitive()",test_isPrimitive:function(){Y.Assert.isTrue(Kevlar.isPrimitive(1),"Test with integer");Y.Assert.isTrue(Kevlar.isPrimitive(-3),"Test with negative integer");Y.Assert.isTrue(Kevlar.isPrimitive(1.4),"Test with floating number");Y.Assert.isTrue(Kevlar.isPrimitive(Number.MAX_VALUE),"Test with Number.MAX_VALUE");Y.Assert.isTrue(Kevlar.isPrimitive(Math.PI),"Test with Math.PI");Y.Assert.isTrue(Kevlar.isPrimitive(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isPrimitive("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isPrimitive(true),"Test with boolean true");Y.Assert.isTrue(Kevlar.isPrimitive(false),"Test with boolean false");Y.Assert.isFalse(Kevlar.isPrimitive(null),"Test with null");Y.Assert.isFalse(Kevlar.isPrimitive(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isPrimitive({}),"Test with object");Y.Assert.isFalse(Kevlar.isPrimitive([]),"Test with array");Y.Assert.isFalse(Kevlar.isPrimitive(new Kevlar.util.Observable()),"Test with object instance")}},{name:"Test isString()",test_isString:function(){var a=new String("foo");Y.Assert.isTrue(Kevlar.isString(""),"Test with empty string");Y.Assert.isTrue(Kevlar.isString("foo"),"Test with non empty string");Y.Assert.isTrue(Kevlar.isString(String("")),"Test with String() syntax");Y.Assert.isFalse(Kevlar.isString(new String("")),"Test with new String() syntax");Y.Assert.isFalse(Kevlar.isString(1),"Test with number");Y.Assert.isFalse(Kevlar.isString(true),"Test with boolean");Y.Assert.isFalse(Kevlar.isString(null),"Test with null");Y.Assert.isFalse(Kevlar.isString(undefined),"Test with undefined");Y.Assert.isFalse(Kevlar.isString([]),"Test with array");Y.Assert.isFalse(Kevlar.isString({}),"Test with number")}},{name:"Test namespace()",test_namespace:function(){var a=window;Kevlar.namespace("FooTest1");Y.Assert.isNotUndefined(a.FooTest1,"Test creation with a single top-level namespace");Kevlar.namespace("FooTest2","FooTest3","FooTest4");Y.Assert.isNotUndefined(a.FooTest2,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest3,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest4,"Test creation with multiple top level namespaces");Kevlar.namespace("FooTest5","FooTest5.ns1","FooTest5.ns1.ns2","FooTest5.ns1.ns2.ns3");Y.Assert.isNotUndefined(a.FooTest5,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2.ns3,"Test a chain of namespaces, starting from a top-level");Kevlar.namespace("FooTest6.ns1","FooTest7.ns1");Y.Assert.isNotUndefined(a.FooTest6.ns1,"Test creating lower level namespaces without first defining the top level");Y.Assert.isNotUndefined(a.FooTest7.ns1,"Test creating lower level namespaces without first defining the top level");Kevlar.namespace("FooTest8","FooTest8.ns1.ns2");Y.Assert.isNotUndefined(a.FooTest8,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1.ns2,"Test creating a lower level namespace without defining the middle level");FooTest8.prop1="foo";Kevlar.namespace("FooTest8");Y.Assert.areEqual("foo",FooTest8.prop1,"Ensure existing namespaces are not overwritten")}},{name:"Test toArray()",test_toArray:function(){Y.Assert.isArray(Kevlar.toArray(document.getElementsByTagName("body")),"Test with node list")}},{name:"Test extend()","extend() should set up simple prototype-chaining inheritance":function(){var c=Kevlar.extend(Object,{constructor:function(d){Kevlar.apply(this,d);this.isBadass=false}});var b=Kevlar.extend(c,{constructor:function(){b.superclass.constructor.apply(this,arguments);this.isBadass=true}});var a=new b({davis:"isAwesome"});Y.Assert.areEqual("isAwesome",a.davis,"Test if David is awesome");Y.Assert.isTrue(a.isBadass,"Test if David is badass");Y.Assert.isFunction(a.override,"Test if extend added the override method");Y.ObjectAssert.areEqual({isBadass:true,davis:"isAwesome"},a,"Test if David is badass and awesome")},"extend() should add static 'constructor' property to the class (constructor function)":function(){var a=Kevlar.extend(Object,{});Y.Assert.areSame(a.constructor,a,"static 'constructor' property not added to constructor function that refers to constructor function")},"extend() should add static 'constructor' property to a subclass (constructor function)":function(){var a=Kevlar.extend(Object,{});var b=Kevlar.extend(a,{});Y.Assert.areSame(b.constructor,b,"static 'constructor' property not added to constructor function that refers to constructor function")},"extend() should add static 'superclass' property to a subclass (constructor function) that refers to its superclass prototype":function(){var a=Kevlar.extend(Object,{});var b=Kevlar.extend(a,{});Y.Assert.areSame(b.superclass,a.prototype,"static 'superclass' property not added to constructor function that refers to constructor function")},"extend() should be able to add in a single mixin class into another class":function(){var d=false;var c=Kevlar.extend(Object,{mixinFn:function(){d=true}});var b=Kevlar.extend(Object,[c],{});var a=new b();a.mixinFn();Y.Assert.isTrue(d,"The mixin function was not properly added to MyClass.")},"extend() should not overwrite a class's methods/properties with a mixin's methods/properties":function(){var c=null;var d=Kevlar.extend(Object,{testProp:"Mixin defined",testMethod:function(){c="Mixin defined"}});var b=Kevlar.extend(Object,[d],{testProp:"MyClass defined",testMethod:function(){c="MyClass defined"}});var a=new b();Y.Assert.areSame("MyClass defined",a.testProp,"The mixin should not overwrite the class's properties");a.testMethod();Y.Assert.areSame("MyClass defined",c,"The mixin's method should not have overwritten the class's method.")},"extend() should have later-defined mixins take precedence over earlier-defined mixins":function(){var b=Kevlar.extend(Object,{testProp:"Mixin1 defined"});var d=Kevlar.extend(Object,{testProp:"Mixin2 defined"});var c=Kevlar.extend(Object,[b,d],{});var a=new c();Y.Assert.areSame("Mixin2 defined",a.testProp,"The second mixin's properties/methods should take precedence over the first one's.")},"extend() should have set up the hasMixin() method, which should check the class for a given mixin":function(){var c=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,{});var a=Kevlar.extend(Object,[c],{});Y.Assert.isTrue(a.hasMixin(c),"MyClass should have the mixin 'Mixin'");Y.Assert.isFalse(a.hasMixin(b),"MyClass should *not* have the mixin 'SomeOtherMixin'")},"extend() should have set up the hasMixin() method, which should check the class and all of its superclasses for a given mixin":function(){var f=Kevlar.extend(Object,{});var d=Kevlar.extend(Object,{});var e=Kevlar.extend(Object,{});var h=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,[f],{});var a=Kevlar.extend(b,[d],{});var j=Kevlar.extend(a,[e],{});for(var c=0;c<=1;c++){var g=(c===0)?"initial":"cached";Y.Assert.isTrue(j.hasMixin(f),"MyClass should have the mixin 'Mixin' from its superclass's superclass. pass = "+g);Y.Assert.isTrue(j.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on its superclass. pass = "+g);Y.Assert.isTrue(j.hasMixin(e),"MyClass should have the mixin 'SomeOtherMixin2' on itself. pass = "+g);Y.Assert.isFalse(j.hasMixin(h),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+g)}},"extend() should have set up the hasMixin() method, which should work with mixins and classes defined by regular functions (not using extend())":function(){var g=function(){};var d=function(){};var h=function(){};var b=function(){};var f=Kevlar.extend(b,[g],{});var a=Kevlar.extend(f,[d],{});for(var c=0;c<=1;c++){var e=(c===0)?"initial":"cached";Y.Assert.isTrue(a.hasMixin(g),"MyClass should have the mixin 'Mixin' from its superclass. pass = "+e);Y.Assert.isTrue(a.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on itself. pass = "+e);Y.Assert.isFalse(a.hasMixin(h),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+e)}},"extend() should have set up the hasMixin() method on the subclass's prototype, which should work as the static one on an instance's class":function(){var f=Kevlar.extend(Object,{});var d=Kevlar.extend(Object,{});var e=Kevlar.extend(Object,{});var j=Kevlar.extend(Object,{});var b=Kevlar.extend(Object,[f],{});var a=Kevlar.extend(b,[d],{});var k=Kevlar.extend(a,[e],{});var h=new k();for(var c=0;c<=1;c++){var g=(c===0)?"initial":"cached";Y.Assert.isTrue(h.hasMixin(f),"MyClass should have the mixin 'Mixin' from its superclass's superclass. pass = "+g);Y.Assert.isTrue(h.hasMixin(d),"MyClass should have the mixin 'SomeOtherMixin' on its superclass. pass = "+g);Y.Assert.isTrue(h.hasMixin(e),"MyClass should have the mixin 'SomeOtherMixin2' on itself. pass = "+g);Y.Assert.isFalse(h.hasMixin(j),"MyClass should *not* have the mixin 'NobodyHasThisMixin'. pass = "+g)}}},{name:"Test isInstanceOf()","isInstanceOf() should return false for any primitive type":function(){Y.Assert.isFalse(Kevlar.isInstanceOf(undefined,Object),"isInstanceOf should have returned false when given undefined");Y.Assert.isFalse(Kevlar.isInstanceOf(null,Object),"isInstanceOf should have returned false when given null");Y.Assert.isFalse(Kevlar.isInstanceOf(1,Object),"isInstanceOf should have returned false when given a number");Y.Assert.isFalse(Kevlar.isInstanceOf("hi",Object),"isInstanceOf should have returned false when given a string");Y.Assert.isFalse(Kevlar.isInstanceOf(true,Object),"isInstanceOf should have returned false when given a boolean")},"isInstanceOf() should return true when testing an anonymous object with the Object constructor":function(){Y.Assert.isTrue(Kevlar.isInstanceOf({},Object),"isInstanceOf should have returned true")},"isInstanceOf() should return true when testing an object of a class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var b=new a();Y.Assert.isTrue(Kevlar.isInstanceOf(b,a),"Should have been true. myInstance is an instance of MyClass")},"isInstanceOf() should return true when testing an object that is a subclass of a given class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var c=Kevlar.extend(a,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,a),"Should have been true. myInstance is an instance of MySubClass, which inherits from MyClass")},"isInstanceOf() should return false when testing an object that is not an instance of a given class":function(){var a=Kevlar.extend(Object,{constructor:function(){}});var c=Kevlar.extend(Object,{constructor:function(){}});var b=new c();Y.Assert.isFalse(Kevlar.isInstanceOf(b,a),"Should have been false. myInstance is not an instance of MyClass")},"isInstanceOf() should return true when testing an object that has a given mixin class":function(){var c=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[c],{constructor:function(){}});var b=new a();Y.Assert.isTrue(Kevlar.isInstanceOf(b,c),"Should have been true. myInstance has the mixin MyMixinClass")},"isInstanceOf() should return true when testing an object that has a given mixin class implemented in its superclass":function(){var d=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[d],{constructor:function(){}});var c=Kevlar.extend(a,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,d),"Should have been true. myInstance has the mixin MyMixinClass through its superclass")},"isInstanceOf() should return true when testing an object that has a given mixin class implemented in its superclass's superclass":function(){var e=Kevlar.extend(Object,{constructor:function(){}});var a=Kevlar.extend(Object,[e],{constructor:function(){}});var d=Kevlar.extend(a,{constructor:function(){}});var c=Kevlar.extend(d,{constructor:function(){}});var b=new c();Y.Assert.isTrue(Kevlar.isInstanceOf(b,e),"Should have been true. myInstance has the mixin MyMixinClass through its superclass's superclass")}}]});Ext.test.Session.addSuite({name:"Kevlar.Object",items:[{name:"Test clone()","clone() should return primitive types as-is":function(){Y.Assert.areSame(undefined,Kevlar.Object.clone(undefined),"clone() not returning undefined when provided undefined.");Y.Assert.areSame(null,Kevlar.Object.clone(null),"clone() not returning null when provided null.");Y.Assert.areSame(true,Kevlar.Object.clone(true),"clone() not returning true when provided true.");Y.Assert.areSame(false,Kevlar.Object.clone(false),"clone() not returning false when provided false.");Y.Assert.areSame(0,Kevlar.Object.clone(0),"clone() not returning 0 when provided 0.");Y.Assert.areSame(1,Kevlar.Object.clone(1),"clone() not returning 1 when provided 1.");Y.Assert.areSame("",Kevlar.Object.clone(""),"clone() not returning empty string when provided an empty string.");Y.Assert.areSame("hi",Kevlar.Object.clone("hi"),"clone() not returning string 'hi' when provided string 'hi'.")},"clone() should copy an array of primitives":function(){var a=[1,2,3,4,5];Y.Assert.areNotSame(a,Kevlar.Object.clone(a),"clone() returning same reference to array.");Y.Assert.isTrue(Kevlar.Object.isEqual([1,2,3,4,5],Kevlar.Object.clone(a)),"clone() not properly copying a simple array.")},"clone() should deep copy an array of mixed primitives and objects":function(){var a=[{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]];Y.Assert.areNotSame(a,Kevlar.Object.clone(a),"clone() returning same reference to complex array.");Y.Assert.isTrue(Kevlar.Object.isEqual([{a:{inner:1},b:2},1,"asdf",[1,2,{a:1}]],Kevlar.Object.clone(a)),"clone() not properly deep copying a complex array.");Y.Assert.areNotSame(a[0],Kevlar.Object.clone(a)[0],"clone() not properly deep copying a complex array. first element has same reference for original and copy.");Y.Assert.areNotSame(a[0].a,Kevlar.Object.clone(a)[0].a,"clone() not properly deep copying a complex array. first element, 'a' object, has same reference for original and copy.");Y.Assert.areSame(a[0].a,Kevlar.Object.clone(a,false)[0].a,"clone() not properly shallow copying a complex array. first element, 'a' object, does not have same reference for original and copy.")},"clone() should copy a simple object of primitives":function(){var a={a:1,b:2};Y.Assert.areNotSame(a,Kevlar.Object.clone(a),"clone() returning same reference to simple object.");Y.Assert.isTrue(Kevlar.Object.isEqual({a:1,b:2},Kevlar.Object.clone(a)),"clone() not properly copying a simple object.")},"clone() should deep copy an object of primitives, nested arrays, and nested objects":function(){var a={a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]]};Y.Assert.areNotSame(a,Kevlar.Object.clone(a),"clone() returning same reference to complex object.");Y.Assert.isTrue(Kevlar.Object.isEqual({a:1,b:{a:1,b:[1,2,3],c:{a:null,b:undefined,c:true,d:false,e:"ohai"}},c:[1,[1,2]]},Kevlar.Object.clone(a)),"clone() not properly deep copying a complex object.");Y.Assert.areNotSame(a.b,Kevlar.Object.clone(a).b,"clone() not properly deep copying a complex object. property 'b' has same reference for original and copy.");Y.Assert.areNotSame(a.b.c,Kevlar.Object.clone(a).b.c,"clone() not properly deep copying a complex object. property 'b.c' has same reference for original and copy. Nested object inside nested object not getting copied.");Y.Assert.areSame(a.b.c,Kevlar.Object.clone(a,false).b.c,"clone() with 'deep' set to false (shallow copy mode) is still deep copying a complex object. property 'b.c' does not have same reference for original and copy.")},"clone() should not copy prototype properties of instantiated objects":function(){var a=function(){this.ownVar=1};a.prototype.prototypeVar=2;var b=new a();var c=Kevlar.Object.clone(b);Y.Assert.isTrue(c.hasOwnProperty("ownVar"),"clone() did not copy the owned property 'ownVar'");Y.Assert.areSame(1,c.ownVar,"clone() did not copy the owned property 'ownVar' with the correct value");Y.Assert.isFalse(c.hasOwnProperty("prototypeVar"),"clone() copied the prototype property 'prototypeVar'. It should not have.")}},{name:"Test isEqual()","isEqual() should work with all datatype comparisons (primitive and array/object)":function(){var a=Kevlar.Object.isEqual;Y.Assert.isTrue(a(undefined,undefined),"Error: undefined !== undefined");Y.Assert.isFalse(a(undefined,null),"Error: undefined === null");Y.Assert.isFalse(a(undefined,true),"Error: undefined === true");Y.Assert.isFalse(a(undefined,false),"Error: undefined === false");Y.Assert.isFalse(a(undefined,0),"Error: undefined === 0");Y.Assert.isFalse(a(undefined,""),"Error: undefined === ''");Y.Assert.isFalse(a(undefined,{}),"Error: undefined === {}");Y.Assert.isFalse(a(undefined,{a:1}),"Error: undefined === { a : 1 }");Y.Assert.isFalse(a(undefined,[]),"Error: undefined === []");Y.Assert.isFalse(a(undefined,[1,2,3]),"Error: undefined === [ 1,2,3 ]");Y.Assert.isFalse(a(undefined,42),"Error: undefined === 42");Y.Assert.isFalse(a(undefined,"test"),"Error: undefined === 'test'");Y.Assert.isTrue(a(null,null),"Error: null !== null");Y.Assert.isFalse(a(null,undefined),"Error: null === undefined");Y.Assert.isFalse(a(null,true),"Error: null === true");Y.Assert.isFalse(a(null,false),"Error: null === false");Y.Assert.isFalse(a(null,0),"Error: null === 0");Y.Assert.isFalse(a(null,""),"Error: null === ''");Y.Assert.isFalse(a(null,{}),"Error: null === {}");Y.Assert.isFalse(a(null,{a:1}),"Error: null === { a : 1 }");Y.Assert.isFalse(a(null,[]),"Error: null === []");Y.Assert.isFalse(a(null,[1,2,3]),"Error: null === [ 1,2,3 ]");Y.Assert.isFalse(a(null,42),"Error: null === 42");Y.Assert.isFalse(a(null,"test"),"Error: null === 'test'");Y.Assert.isTrue(a(true,true),"Error: true !== true");Y.Assert.isTrue(a(false,false),"Error: false !== true");Y.Assert.isFalse(a(true,false),"Error: true === false");Y.Assert.isFalse(a(false,true),"Error: false === true");Y.Assert.isFalse(a(false,0),"Error: false === 0");Y.Assert.isFalse(a(true,1),"Error: true === 1");Y.Assert.isFalse(a(false,""),"Error: false === ''");Y.Assert.isFalse(a(true,"true"),"Error: true === 'true'");Y.Assert.isTrue(a(0,0),"Error: 0 !== 0");Y.Assert.isTrue(a(1,1),"Error: 1 !== 1");Y.Assert.isTrue(a(-1,-1),"Error: -1 !== -1");Y.Assert.isFalse(a(0,1),"Error: 0 === 1");Y.Assert.isFalse(a(1,0),"Error: 1 === 0");Y.Assert.isFalse(a(1,2),"Error: 1 === 2");Y.Assert.isFalse(a(0,""),"Error: 0 === ''");Y.Assert.isFalse(a(1,"1"),"Error: 1 === '1'");Y.Assert.isTrue(a("",""),"Error: '' !== ''");Y.Assert.isTrue(a("asdf","asdf"),"Error: 'asdf' !== 'asdf'");Y.Assert.isFalse(a("",0),"Error: '' === 0");Y.Assert.isFalse(a("asdf","asdf2"),"Error: 'asdf' === 'asdf2'");Y.Assert.isFalse(a(0,"0"),"Error: 0 === '0'");Y.Assert.isFalse(a("0",0),"Error: '0' === 0");Y.Assert.isFalse(a(1,"1"),"Error: 1 === '1'");Y.Assert.isFalse(a("1",1),"Error: '1' === 1")},"isEqual() should work with deep object comparisons":function(){var v=Kevlar.Object.isEqual;var y={a:"text",b:[0,1]};var x={a:"text",b:[0,1]};var w={a:"text",b:0};var u={a:"text",b:false};var t={a:"text",b:[1,0]};var s={a:"text",b:[1,0],f:function(){this.f=this.b}};var r={a:"text",b:[1,0],f:function(){this.f=this.b}};var q={a:"text",b:[1,0],f:function(){this.a=this.b}};var p={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var o={a:"text",c:{b:[1,0],f:function(){this.a=this.b}}};var n={a:"text",b:null};var m={a:"text",b:undefined};Y.Assert.isTrue(v(y,x),"Error w/ object comparison. a !== b");Y.Assert.isFalse(v(y,w),"Error w/ object comparison. a === c");Y.Assert.isFalse(v(w,u),"Error w/ object comparison. c === d");Y.Assert.isFalse(v(y,t),"Error w/ object comparison. a === e");Y.Assert.isTrue(v(s,r),"Error w/ object comparison. f !== g");Y.Assert.isFalse(v(r,q),"Error w/ object comparison. g === h");Y.Assert.isTrue(v(p,o),"Error w/ object comparison. i !== j");Y.Assert.isFalse(v(u,n),"Error w/ object comparison. d === k");Y.Assert.isFalse(v(n,p),"Error w/ object comparison. k === i")},"isEqual() should work with deep array comparisons":function(){var B=Kevlar.Object.isEqual;var M=[];var L=[];var K=[1];var J=[1];var I=[2];var H=[2];var G=[1,2,3];var F=[1,2,3];var E=[1,{a:1,b:2},3];var D=[1,{a:1,b:2},3];var C=[[1,2,3],{a:1,b:2},3];var A=[[1,2,3],{a:1,b:2},3];var z=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var y=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[1,2]},{c:3}];var x=[[1,2,3],{a:1,b:2},4];var w=[[1,2,3],{a:11,b:2},4];var v=[[1,22,3],{a:1,b:2},4];var u=[[1,{a:1,b:2,c:3},[1,1,3]],{a:1,b:[1,2]},{c:3}];var t=[[1,{a:1,b:2,c:3},[1,2,3]],{a:1,b:[2,2]},{c:3}];Y.Assert.isTrue(B(M,L),"Error w/ array comparison. a !== b");Y.Assert.isTrue(B(K,J),"Error w/ array comparison. c !== d");Y.Assert.isTrue(B(I,H),"Error w/ array comparison. e !== f");Y.Assert.isTrue(B(G,F),"Error w/ array comparison. g !== h");Y.Assert.isTrue(B(E,D),"Error w/ array comparison. i !== j");Y.Assert.isTrue(B(C,A),"Error w/ array comparison. k !== l");Y.Assert.isTrue(B(z,y),"Error w/ array comparison. m !== n");Y.Assert.isFalse(B(M,K),"Error w/ array comparison. a === c");Y.Assert.isFalse(B(L,J),"Error w/ array comparison. b === d");Y.Assert.isFalse(B(K,I),"Error w/ array comparison. c === e");Y.Assert.isFalse(B(J,H),"Error w/ array comparison. d === f");Y.Assert.isFalse(B(I,G),"Error w/ array comparison. e === g");Y.Assert.isFalse(B(H,F),"Error w/ array comparison. f === h");Y.Assert.isFalse(B(G,E),"Error w/ array comparison. g === i");Y.Assert.isFalse(B(F,D),"Error w/ array comparison. h === j");Y.Assert.isFalse(B(E,C),"Error w/ array comparison. i === k");Y.Assert.isFalse(B(D,A),"Error w/ array comparison. j === l");Y.Assert.isFalse(B(C,z),"Error w/ array comparison. k === m");Y.Assert.isFalse(B(A,y),"Error w/ array comparison. l === n");Y.Assert.isFalse(B(E,x),"Error w/ array comparison. i === o");Y.Assert.isFalse(B(C,w),"Error w/ array comparison. k === p");Y.Assert.isFalse(B(z,u),"Error w/ array comparison. m === r");Y.Assert.isFalse(B(y,t),"Error w/ array comparison. n === s")},"isEqual() should be able to shallow compare, with the 'deep' flag set to false, in case objects refer to each other":function(){var g=Kevlar.Object.isEqual;var j={};var i={};j.obj2=i;i.obj1=j;var d=[j,i];var c=[j,i];var f;try{f=Kevlar.Object.isEqual(d,c,false)}catch(h){Y.Assert.fail("Error w/ shallow array comparison and deep flag set to false. Comparison must be going deep, as this error would come from call stack size being reached.")}Y.Assert.isTrue(f,"Error w/ shallow array comparison. a !== b")}},{name:"Test objLength()","objLength() should return 0 for an empty object":function(){var a={};Y.Assert.areSame(0,Kevlar.Object.objLength(a))},"objLength() should return 0 for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.areSame(0,Kevlar.Object.objLength(b))},"objLength() should return the number of owned properties in the object":function(){var a={prop1:"1",prop2:"2"};Y.Assert.areSame(2,Kevlar.Object.objLength(a))},"objLength() should return the number of owned properties in the object, even if they are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.areSame(5,Kevlar.Object.objLength(a))}},{name:"Test isEmpty()","isEmpty() should return true for an empty object":function(){var a={};Y.Assert.isTrue(Kevlar.Object.isEmpty(a))},"isEmpty() should return true for an empty object, even if the object has prototype properties":function(){var a=function(){};a.prototype.prop="prototype property";var b=new a();Y.Assert.isTrue(Kevlar.Object.isEmpty(b))},"isEmpty() should return false if the object owns properties":function(){var a={prop1:"1",prop2:"2"};Y.Assert.isFalse(Kevlar.Object.isEmpty(a))},"isEmpty() should return false if the object owns properties, even if the properties are undefined or falsy":function(){var a={prop1:undefined,prop2:null,prop3:false,prop4:0,prop5:""};Y.Assert.isFalse(Kevlar.Object.isEmpty(a))}}]});Ext.test.Session.addTest("Kevlar.data",{name:"Kevlar.data.Field",setUp:function(){},_should:{error:{"Instantiating a Field without a 'name' should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with an undefined 'name' argument should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with an undefined 'name' property should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with a null 'name' argument should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with a null 'name' property should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with an empty 'name' argument should throw an error":"no 'name' property provided to Kevlar.data.Field constructor","Instantiating a Field with an empty 'name' property should throw an error":"no 'name' property provided to Kevlar.data.Field constructor"}},"Instantiating a Field without a 'name' should throw an error":function(){var a=new Kevlar.data.Field()},"Instantiating a Field with an undefined 'name' argument should throw an error":function(){var a=new Kevlar.data.Field(undefined)},"Instantiating a Field with an undefined 'name' property should throw an error":function(){var a=new Kevlar.data.Field({name:undefined})},"Instantiating a Field with a null 'name' argument should throw an error":function(){var a=new Kevlar.data.Field(null)},"Instantiating a Field with a null 'name' property should throw an error":function(){var a=new Kevlar.data.Field({name:null})},"Instantiating a Field with an empty 'name' argument should throw an error":function(){var a=new Kevlar.data.Field("")},"Instantiating a Field with an empty 'name' property should throw an error":function(){var a=new Kevlar.data.Field({name:""})},"The name property should be retrievable by getName()":function(){var a=new Kevlar.data.Field({name:"testName"});Y.Assert.areSame("testName",a.getName(),"getName() not properly retriving Field's name. Was looking for 'testName'.");var c=new Kevlar.data.Field({name:"_"});Y.Assert.areSame("_",c.getName(),"getName() not properly retriving Field's name. Was looking for '_'.");var b=new Kevlar.data.Field({name:"abc"});Y.Assert.areSame("abc",b.getName(),"getName() not properly retriving Field's name. Was looking for 'abc'.")},"Providing the field name as a number directly to the constructor argument should be converted to a string for the field's name":function(){var a=new Kevlar.data.Field(0);Y.Assert.areSame("0",a.getName(),"the field name should have been converted to a string")},"Providing the field name as a property on the config should be converted to a string for the field's name":function(){var a=new Kevlar.data.Field({name:0});Y.Assert.areSame("0",a.getName(),"the field name should have been converted to a string")},"A default provided as the keyword 'default' should be accepted properly as defaultValue":function(){var a=new Kevlar.data.Field({name:"TestField","default":1});Y.Assert.areSame(1,a.defaultValue)},"A default provided as the keyword 'default' that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.data.Field({name:"TestField","default":function(){return 1}});Y.Assert.areSame(1,a.defaultValue)},"A default provided as defaultValue should be accepted properly":function(){var a=new Kevlar.data.Field({name:"TestField",defaultValue:1});Y.Assert.areSame(1,a.defaultValue)},"A default provided as defaultValue that is a function should be executed and set properly to defaultValue":function(){var a=new Kevlar.data.Field({name:"TestField",defaultValue:function(){return 1}});Y.Assert.areSame(1,a.defaultValue)},"A defaultValue provided as an object should be recursed for functions, and those functions' return values should be used in the default":function(){var b=new Kevlar.data.Field({name:"TestField","default":{a:"A",b:{innerB1:function(){return"B1"},innerB2:"B2"},c:{innerC1:"C",innerC2:function(){return"C2"}}}});var a=b.defaultValue;Y.Assert.areSame("A",a.a,"The 'default' config provided as an object should have had the value 'A' for property 'a'.");Y.Assert.areSame("B1",a.b.innerB1,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.");Y.Assert.areSame("C2",a.c.innerC2,"The 'default' config provided as an object should have been recursed for functions, and their return values used as the properties.")}});Ext.test.Session.addSuite("Kevlar.data",{name:"Kevlar.data.Model",items:[{name:"Test Fields Inheritance",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},removeArrayDuplicates:function(b){var c=[],e={};for(var d=0,a=b.length;d<a;d++){e[b[d]]=0}for(d in e){if(e.hasOwnProperty(d)){c.push(d)}}return c},assertFieldsHashCorrect:function(){var a=Kevlar.toArray(arguments),c,f;var b=[];for(c=0,f=a.length;c<f;c++){var e=a[c].prototype;if(e.hasOwnProperty("fields")){b=b.concat(a[c].prototype.fields)}}var l=[];for(c=0,f=b.length;c<f;c++){var k=new Kevlar.data.Field(b[c]).getName();l.push(k)}l=this.removeArrayDuplicates(l);var d=l.length;var h=new a[a.length-1](),j=h.fields;var g=Kevlar.Object.objLength(j,true);Y.Assert.areSame(d,g,"There should be the same number of resulting fields in the 'instanceFields' hash as the original 'fields' arrays of the Model classes.");for(c=0,f=l.length;c<f;c++){Y.ObjectAssert.hasKey(l[c],j,"The Model (last arg to assertFieldsHashCorrect) should have defined the '"+l[c]+"' field in its final 'fields' hash")}},"The Kevlar.data.Model class itself (i.e. no superclass Model) should just have the fields defined on its prototype.":function(){var a=Kevlar.data.Model;this.assertFieldsHashCorrect(a)},"Fields should inherit from a Model subclass's superclass when the subclass defines no fields of its own":function(){var b=Kevlar.data.Model;var a=Kevlar.extend(b,{});this.assertFieldsHashCorrect(b,a)},"Fields should inherit from a Model subclass's superclass when the subclass does define fields of its own":function(){var c=Kevlar.data.Model;var a=Kevlar.extend(c,{fields:["a","b"]});this.assertFieldsHashCorrect(c,a);var b=(new a()).fields;Y.ObjectAssert.hasKey("a",b,"SubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",b,"SubClassModel should have the 'b' field defined in its final 'fields' hash.")},"Fields should inherit from a Model subclass's superclass, and its superclass as well (i.e. more than one level up)":function(){var d=Kevlar.data.Model;var a=Kevlar.extend(d,{fields:["a","b"]});var c=Kevlar.extend(a,{fields:["c","d","e"]});this.assertFieldsHashCorrect(d,a,c);var b=(new c()).fields;Y.ObjectAssert.hasKey("a",b,"SubSubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",b,"SubSubClassModel should have the 'b' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("c",b,"SubSubClassModel should have the 'c' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("d",b,"SubSubClassModel should have the 'd' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("e",b,"SubSubClassModel should have the 'e' field defined in its final 'fields' hash.")},"Fields should inherit from a Model subclass's superclass, and all of its superclasses (i.e. more than two levels up)":function(){var e=Kevlar.data.Model;var b=Kevlar.extend(e,{fields:["a","b"]});var d=Kevlar.extend(b,{fields:["c","d","e"]});var a=Kevlar.extend(d,{fields:["f"]});this.assertFieldsHashCorrect(e,b,d,a);var c=(new a()).fields;Y.ObjectAssert.hasKey("a",c,"SubSubSubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",c,"SubSubSubClassModel should have the 'b' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("c",c,"SubSubSubClassModel should have the 'c' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("d",c,"SubSubSubClassModel should have the 'd' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("e",c,"SubSubSubClassModel should have the 'e' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("f",c,"SubSubSubClassModel should have the 'f' field defined in its final 'fields' hash.")},"Field definitions defined in a subclass should take precedence over field definitions in a superclass":function(){var d=Kevlar.data.Model;var a=Kevlar.extend(d,{fields:[{name:"a",defaultValue:1}]});var c=Kevlar.extend(a,{fields:[{name:"a",defaultValue:2},"b"]});this.assertFieldsHashCorrect(d,a,c);var b=(new c()).fields;Y.ObjectAssert.hasKey("a",b,"SubSubSubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",b,"SubSubSubClassModel should have the 'b' field defined in its final 'fields' hash.");Y.Assert.areSame(2,b.a.defaultValue,"The field in the subclass should have overridden its superclass")},"A subclass that doesn't define any fields should inherit all of them from its superclass(es)":function(){var d=Kevlar.data.Model;var a=Kevlar.extend(d,{fields:["a","b"]});var c=Kevlar.extend(a,{});this.assertFieldsHashCorrect(d,a,c);var b=(new c()).fields;Y.ObjectAssert.hasKey("a",b,"SubSubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",b,"SubSubClassModel should have the 'b' field defined in its final 'fields' hash.")},"A superclass that doesn't define any fields should be skipped for fields, but the subclass should still inherit from superclasses above it":function(){var d=Kevlar.data.Model;var a=Kevlar.extend(d,{});var c=Kevlar.extend(a,{fields:["a","b"]});this.assertFieldsHashCorrect(d,a,c);var b=(new c()).fields;Y.ObjectAssert.hasKey("a",b,"SubSubClassModel should have the 'a' field defined in its final 'fields' hash.");Y.ObjectAssert.hasKey("b",b,"SubSubClassModel should have the 'b' field defined in its final 'fields' hash.")}},{name:"Test Initialization",ttype:"testsuite",items:[{name:"Test datachange event upon initialization",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"The Model should not fire its 'datachange' event during the set of the initial data":function(){var b=false;var a=new this.TestModel({data:{field1:"field1 value"},listeners:{datachange:function(){b=true}}});Y.Assert.isFalse(b,"The datachange event should not have fired during the set of the initial data")},"The Model should fire its 'datachange' event when a field's data is set externally":function(){var b=false;var a=new this.TestModel({listeners:{datachange:function(){b=true}}});a.set("field1","value1");Y.Assert.isTrue(b,"The datachange event should have been fired during the set of the new data")}},{name:"Test that the initial default values are applied",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"A field with a defaultValue but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("field2's default",a.get("field2"))},"A field with a defaultValue that is a function, but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("field3's default",a.get("field3"))},"A field with a defaultValue and also provided data should have its provided data when retrieved":function(){var a=new this.TestModel({data:{field2:"field2's data"}});Y.Assert.areSame("field2's data",a.get("field2"),"The 'default' specified on the Field should *not* have been applied, since it has a value.")}}]},{name:"Test get()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"running get() on a field with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.get("field1"))},"running get() on a field with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({data:{field1:"initial value"}});Y.Assert.areSame("initial value",a.get("field1"))},"running get() on a field with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("field2's default",a.get("field2"))},"running get() on a field with an initial value and a default value should return the initial value":function(){var a=new this.TestModel({data:{field2:"initial value"}});Y.Assert.areSame("initial value",a.get("field2"))},"running get() on a field with no initial value but does have a default value which is a function should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("field3's default",a.get("field3"))}},{name:"Test getAll()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"getAll() should return a shallow copy of the data, so that the returned object may be modified without messing up the Model":function(){var a=new this.TestModel({data:{field1:"field1data"}});var b=a.getAll();b.field1="newfield1data";Y.Assert.areSame("field1data",a.get("field1"),"field1 in the testModel should not have been modified. getAll() not returning at least a shallow copy of the data?")}},{name:"Test set()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},assertFieldAcceptsAll:function(a,b){a.set(b,undefined);Y.Assert.isUndefined(a.get(b),b+"'s value should have the value set by set() (undefined).");a.set(b,null);Y.Assert.isNull(a.get(b),b+"'s value should have the value set by set() (null).");a.set(b,true);Y.Assert.isTrue(a.get(b),b+"'s value should have the value set by set() (true).");a.set(b,false);Y.Assert.isFalse(a.get(b),b+"'s value should have the value set by set() (false).");a.set(b,0);Y.Assert.areSame(0,a.get(b),b+"'s value should have the value set by set() (0).");a.set(b,1);Y.Assert.areSame(1,a.get(b),b+"'s value should have the value set by set() (1).");a.set(b,"");Y.Assert.areSame("",a.get(b),b+"'s value should have the value set by set() ('').");a.set(b,"Hello");Y.Assert.areSame("Hello",a.get(b),b+"'s value should have the value set by set() ('Hello').");a.set(b,{});Y.Assert.isObject(a.get(b),b+"'s value should have the value set by set() (object).");a.set(b,[]);Y.Assert.isArray(a.get(b),b+"'s value should have the value set by set() (array).")},"set() should accept all datatypes including falsy values":function(){var a=new this.TestModel();this.assertFieldAcceptsAll(a,"field1")},"set() should accept all datatypes, and still work even with a default value":function(){var a=new this.TestModel();this.assertFieldAcceptsAll(a,"field2")},"set() should accept all datatypes, and still work even with a given value":function(){var a=new this.TestModel({data:{field2:"initial value"}});this.assertFieldAcceptsAll(a,"field2")},"set() should convert a field that has no initial data of its own":function(){var b=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2default"},{name:"field3",convert:function(d,c){return c.get("field1")+" "+c.get("field2")}}]});var a=new b({data:{field1:"field1val"}});Y.Assert.areSame("field1val field2default",a.get("field3"),"field3 should be the concatenation of field1, a space, and field2")},"set() should convert a field that does have initial data of its own":function(){var b=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",convert:function(d,c){return d+" "+c.get("field1")}}]});var a=new b({data:{field1:"field1val",field2:"field2val"}});Y.Assert.areSame("field2val field1val",a.get("field2"),"field2 should be the concatenation of its own value, a space, and field1")},"set() should convert a field with a 'convert' function when it is set() again":function(){var b=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",convert:function(d,c){return d+" "+c.get("field1")}}]});var a=new b({data:{field1:"field1val",field2:"field2val"}});a.set("field2","newfield2value");Y.Assert.areSame("newfield2value field1val",a.get("field2"),"field2 should be the concatenation of its own value, a space, and field2")}},{name:"Test getDefault()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"A field with no defaultValue should return undefined when trying to retrieve its default value":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.getDefault("field1"))},"A defaultValue should be able to be retrieved directly when the field has one":function(){var a=new this.TestModel();Y.Assert.areSame("field2's default",a.getDefault("field2"))},"A defaultValue should be able to be retrieved directly when the defaultValue is a function that returns its default":function(){var a=new this.TestModel();Y.Assert.areSame("field3's default",a.getDefault("field3"))}},{name:"Test isDirty()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"isDirty() should return false after instantiating a Model with no data":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after instantiating a Model with initial data":function(){var a=new this.TestModel({data:{field1:1,field2:2}});Y.Assert.isFalse(a.isDirty())},"isDirty() should return true after setting a field's data":function(){var a=new this.TestModel();a.set("field1",1);Y.Assert.isTrue(a.isDirty())},"isDirty() should return false after setting a field's data, and then rolling back the data":function(){var a=new this.TestModel();a.set("field1",1);a.rollback();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after setting a field's data, and then committing the data":function(){var a=new this.TestModel();a.set("field1",1);a.commit();Y.Assert.isFalse(a.isDirty())}},{name:"Test isModified()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"isModified() should return false for fields that have not been changed":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isModified("field1"),"field1, with no defaultValue, should not be modified");Y.Assert.isFalse(a.isModified("field2"),"field2, with a defaultValue, should not be modified")},"isModified() should return true for fields that have been changed":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");Y.Assert.isTrue(a.isModified("field1"),"field1 should be marked as modified");Y.Assert.isTrue(a.isModified("field2"),"field2 should be marked as modified")},"isModified() should return false for fields that have been changed, but then committed":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");a.commit();Y.Assert.isFalse(a.isModified("field1"),"field1 should have been committed, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("field2"),"field2 should have been committed, and therefore not marked as modified")},"isModified() should return false for fields that have been changed, but then rolled back":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");a.rollback();Y.Assert.isFalse(a.isModified("field1"),"field1 should have been rolled back, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("field2"),"field2 should have been rolled back, and therefore not marked as modified")}},{name:"Test getChanges()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"getChanges() should return a single field that has had its value changed":function(){var a=new this.TestModel();a.set("field1","new value");var b=a.getChanges();Y.Assert.areSame(1,Kevlar.Object.objLength(b),"The changes hash retrieved should have exactly 1 property");Y.Assert.areSame("new value",b.field1,"The change to field1 should have been 'new value'.")},"getChanges() should return multiple fields that have had their values changed":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");var b=a.getChanges();Y.Assert.areSame(2,Kevlar.Object.objLength(b),"The changes hash retrieved should have exactly 2 properties");Y.Assert.areSame("new value 1",b.field1,"The change to field1 should have been 'new value 1'.");Y.Assert.areSame("new value 2",b.field2,"The change to field2 should have been 'new value 2'.")}},{name:"Test commit()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"committing changed data should cause the 'dirty' flag to be reset to false, and getChanges() to return an empty object":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");a.commit();var b=a.getChanges();Y.Assert.areSame(0,Kevlar.Object.objLength(b),"The changes hash retrieved should have exactly 0 properties");Y.Assert.isFalse(a.isDirty(),"The model should no longer be marked as 'dirty'")},"committing changed data should cause rollback() to have no effect":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");a.commit();a.rollback();Y.Assert.areSame("new value 1",a.get("field1"),"field1 should have been 'new value 1'. rollback() should not have had any effect.");Y.Assert.areSame("new value 2",a.get("field2"),"field2 should have been 'new value 2'. rollback() should not have had any effect.")}},{name:"Test rollback()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},"rollback() should revert the model's values back to default values if before any committed set() calls":function(){var a=new this.TestModel();a.set("field1","new value 1");a.set("field2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.isUndefined(a.get("field1"));Y.Assert.areSame("field2's default",a.get("field2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values":function(){var a=new this.TestModel({data:{field1:"original field1",field2:"original field2"}});a.set("field1","new value 1");a.set("field2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original field1",a.get("field1"));Y.Assert.areSame("original field2",a.get("field2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values, when more than one set() call is made":function(){var a=new this.TestModel({data:{field1:"original field1",field2:"original field2"}});a.set("field1","new value 1");a.set("field2","new value 2");a.set("field1","new value 1 - even newer");a.set("field2","new value 2 - even newer");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original field1",a.get("field1"));Y.Assert.areSame("original field2",a.get("field2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")}},{name:"Test save()",setUp:function(){this.TestModel=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default"},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(b,a){return a.get("field1")+" "+a.get("field2")}},{name:"field5",convert:function(b,a){return b+" "+a.get("field2")}}]})},_should:{error:{"save() should throw an error if there is no configured proxy":"Kevlar.data.Model::save() error: Cannot save. No configured proxy."}},"save() should throw an error if there is no configured proxy":function(){var a=new this.TestModel({});a.save();Y.Assert.fail("save() should have thrown an error with no configured proxy")},"save() should call its proxy's update() method when a field has been changed":function(){var c=0;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){c++},supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});b.set("field1","newfield1value");b.save();Y.Assert.areSame(1,c,"The proxy's update() method should have been called exactly once")},"save() should NOT call its proxy's update() method when no fields have been changed":function(){var c=0;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){c++},supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});b.save();Y.Assert.areSame(0,c,"The proxy's update() method should not have not been called, since there are no changes")},"The 'success' callback provided to save() should be called if no fields have been changed, and the proxy's update() method does not need to be called":function(){var a=Kevlar.extend(Kevlar.data.AbstractProxy,{supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});var c=0;b.save({success:function(){c++}});Y.Assert.areSame(1,c,"The 'success' callback provided to save() method should have been called even though there are no changes and the proxy didn't need to persist anything")},"save() should provide the full set of data if the proxy does not support incremental updates":function(){var c;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){c=e},supportsIncrementalUpdates:function(){return false}});var b=new this.TestModel({proxy:new a()});b.set("field1","newfield1value");b.save();Y.Assert.areEqual(5,Kevlar.Object.objLength(c),"The dataToPersist should only have exactly 5 keys, one for each of the fields");Y.ObjectAssert.ownsKeys(["field1","field2","field3","field4","field5"],c)},"save() should provide only the changed data if the proxy does in fact support incremental updates":function(){var c;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){c=e},supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});b.set("field1","newfield1value");b.save();Y.Assert.areEqual(1,Kevlar.Object.objLength(c),"The dataToPersist should only have one key, the one that was changed");Y.ObjectAssert.ownsKeys(["field1"],c,"The dataToPersist should have 'field1'")},"save() should provide only 'persist' fields out of all of its data to the proxy's update() method when the proxy does not support incremental updates":function(){var c;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(f,e){c=f},supportsIncrementalUpdates:function(){return false}});var d=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default",persist:false},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(f,e){return e.get("field1")+" "+e.get("field2")}},{name:"field5",convert:function(f,e){return f+" "+e.get("field2")},persist:false}]});var b=new d({proxy:new a()});b.set("field1","newfield1value");b.save();Y.Assert.areEqual(3,Kevlar.Object.objLength(c),"The dataToPersist should only have 3 keys, the fields that are persisted (i.e. that don't have persist:false)");Y.ObjectAssert.ownsKeys(["field1","field3","field4"],c,"The dataToPersist should only have persisted fields")},"save() should provide only 'persist' fields of the changed fields to the proxy's update() method when the proxy supports incremental updates":function(){var c;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(f,e){c=f},supportsIncrementalUpdates:function(){return true}});var d=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",defaultValue:"field2's default",persist:false},{name:"field3",defaultValue:function(){return"field3's default"}},{name:"field4",convert:function(f,e){return e.get("field1")+" "+e.get("field2")}},{name:"field5",convert:function(f,e){return f+" "+e.get("field2")},persist:false}]});var b=new d({proxy:new a()});b.set("field2","newfield2value");b.set("field3","newfield3value");b.set("field4","newfield4value");b.set("field5","newfield5value");b.save();Y.Assert.areEqual(2,Kevlar.Object.objLength(c),"The dataToPersist should only have 2 keys, the fields that are persisted (i.e. that don't have persist:false), out of the 4 that were modified");Y.ObjectAssert.ownsKeys(["field3","field4"],c,"The dataToPersist should only have persisted fields")},"save() should NOT call its proxy's update() method when only fields that are not to be persisted have been changed":function(){var c=Kevlar.extend(Kevlar.data.Model,{fields:[{name:"field1"},{name:"field2",persist:false}]});var d=0;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(f,e){d++},supportsIncrementalUpdates:function(){return false}});var b=new c({proxy:new a(),data:{field1:"field1value",field2:"field2value"}});b.set("field2","newfield2value");b.save();Y.Assert.areSame(0,d,"The proxy's update() method should not have not been called, since there are no changes to persisted fields")},"Model attributes that are updated (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){window.setTimeout(function(){d.success.call(d.scope||window)},50)},supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});b.set("field1","origValue1");b.set("field2","origValue2");b.save({success:function(){c.resume(function(){Y.Assert.isTrue(b.isDirty(),"The model should still be dirty after the persistence operation. field1 was set after the persistence operation began.");Y.Assert.isTrue(b.isModified("field1"),"field1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(b.isModified("field2"),"field2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue1",b.get("field1"),"a get() operation on field1 should return the new value.");Y.Assert.areSame("origValue2",b.get("field2"),"a get() operation on field2 should return the persisted value. It was not updated since the persistence operation began.")})}});b.set("field1","newValue1");c.wait(100)},"Model attributes that have been persisted should not be persisted again if they haven't changed since the last persist":function(){var c;var a=Kevlar.extend(Kevlar.data.AbstractProxy,{update:function(e,d){c=e;d.success.call(d.scope)},supportsIncrementalUpdates:function(){return true}});var b=new this.TestModel({proxy:new a()});b.set("field1","newfield1value");b.save();Y.Assert.areEqual(1,Kevlar.Object.objLength(c),"The dataToPersist should only have one key after field1 has been changed");Y.ObjectAssert.ownsKeys(["field1"],c,"The dataToPersist should have 'field1'");b.set("field2","newfield2value");b.save();Y.Assert.areEqual(1,Kevlar.Object.objLength(c),"The dataToPersist should only have one key after field2 has been changed");Y.ObjectAssert.ownsKeys(["field2"],c,"The dataToPersist should have 'field2'")}}]});